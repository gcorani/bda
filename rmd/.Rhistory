plt.figure(figsize=(10, 3))
x = np.linspace(0, 1, 100)
for ind, (a, b) in enumerate([(1, 1)]):
y = stats.beta.pdf(x, a, b)
#plt.subplot(1, 3, ind+1)
plt.plot(x, y, label='a = %s\nb = %s' % (a, b))
plt.legend(fontsize=12)
quit
import numpy as np
import pandas as pd
import arviz as az
import scipy.stats as stats
from matplotlib import pyplot as plt
import seaborn as sns
sns.set_theme()
plt.rcParams.update({
"text.usetex": True,
"font.family": "sans-serif",
"font.sans-serif": ["Helvetica"]})
az.style.use('arviz-darkgrid')
plt.figure(figsize=(10, 3))
x = np.linspace(0, 1, 100)
for ind, (a, b) in enumerate([(1, 1)]):
y = stats.beta.pdf(x, a, b)
#plt.subplot(1, 3, ind+1)
plt.plot(x, y, label='a = %s\nb = %s' % (a, b))
plt.legend(fontsize=12)
plt.figure(figsize=(10, 3))
x = np.linspace(0, 1, 100)
for ind, (a, b) in enumerate([(1, 1)]):
y = stats.beta.pdf(x, a, b)
#plt.subplot(1, 3, ind+1)
plt.plot(x, y, label='a = %s\nb = %s' % (a, b))
plt.legend(fontsize=12)
plt.figure(figsize=(10, 3))
x = np.linspace(0, 1, 100)
for ind, (a, b) in enumerate([(1, 1)]):
y = stats.beta.pdf(x, a, b)
#plt.subplot(1, 3, ind+1)
plt.plot(x, y, label='a = %s\nb = %s' % (a, b))
plt.legend(fontsize=12)
plt.ylabel('p ($\theta$)')
import numpy as np
import pandas as pd
import arviz as az
import scipy.stats as stats
from matplotlib import pyplot as plt
import seaborn as sns
sns.set_theme()
plt.rcParams.update({
"text.usetex": True,
"font.family": "sans-serif",
"font.sans-serif": ["Helvetica"]})
az.style.use('arviz-darkgrid')
reticulate::repl_python()
library(reticulate)
quit
use_condaenv("r-reticulate")
reticulate::repl_python()
source("~/switchdrive/devel/etsKernel/varianceETS.R")
pop <- seq(1,7)
pop
start <- sample.int(7,1)
start
runif()
runif(1)
i<-2
proposal <- max(visited[i-1]-1,1)
visited <- vector (length = simul)
start <- sample.int(7,1)
visited[1] <- start
pop     <- seq(1,7)
simul   <- 10000
visited <- vector (length = simul)
start <- sample.int(7,1)
visited[1] <- start
proposal <- max(visited[i-1]-1,1)
proposal
visited[1]
if (runif() < 0.5){
proposal <- min(visited[i-1]+1,7)
}
if (runif(1) < 0.5){
proposal <- min(visited[i-1]+1,7)
}
proposal
visited[1]
pop     <- seq(1,7)
simul   <- 10000
visited <- vector (length = simul)
start <- sample.int(7,1)
visited[1] <- start
for (i in 2:simul){
proposal <- max(visited[i-1]-1,1)
if (runif(1) < 0.5){
proposal <- min(visited[i-1]+1,7)
}
if (proposal > visited[i-1]){
visited[i] <- proposal
}
else {
threshold <- proposal / visited[i-1]
if (runif(1) < threshold){
visited[i] <- proposal
}
else{
visited[i] <- visited[i-1]
}
}
}
visited
p <- pop/sum(p)
pop     <- seq(1,7)
p <- pop/sum(pop)
p
mean(visited==1)
mean(visited==2)
mean(visited==4)
mean(visited==3)
mean(visited==4)
mean(visited==5)
library(reticulate)
use_condaenv("r-reticulate")
include_graphics(fig71)
library(reticulate)
library(png)
use_condaenv("r-reticulate")
include_graphics(fig71.png)
# Random walk
* The samples from the posterior are generated by taking a *random walk*
* The walk starts from a randomly chosen point where the distribution is non zero.
* At each time step we propose the move to a new position $\theta_{\text{proposed}}$.
* We then decide whether or not to accept the proposed move.
* The move is accepted with probability
$$ p_{\text{move}} = min \left(  \frac {p(\theta_{\text{proposed}})} {p(\theta_{\text{current}})}, 1 \right) $$
#  Metropolis algorithm applied to Bernoulli likelihood and beta prior
$p(\theta \mid D) \propto p(D \mid \theta) p(theta) = \theta^{a+y} (1-\theta)^{b+n-y}$
#schiuma
xbar <- 190
mu <- 175
sigma <- 20
n <- 3
sn <- sigma/sqrt(n)
z <- (xbar - mu) / sn #1.299
prob <- 1- pnorm(z) #0.096
z
pnorm(z)
(195 - 180)/27
(195 - 180)/60
15/(40/sqrt(12))
#potenza
delta = 2
z_alpha = qnorm(.95)
sigma <- 4
n <- 36
z1 <- z_alpha - delta * sqrt(n) / sigma
potenza = 1 - pnorm(z1)
z1
potenza
?lm
x <- rnorm(100)
y <- 3*x + 5 + rnorm(100, mean=0, sd=0.1)
plot(x,y)
y <- 3*x + 5 + rnorm(100, mean=0, sd=0.4)
plot(x,y)
y <- 3*x + 5 + rnorm(100, mean=0, sd=0.8)
plot(x,y)
reg <- lm(y~x)
reg$coefficients
reg$residuals
sd(reg$residuals)
sd(reg$residuals)*1.96
predict(reg, x=1)
predict(reg, newdata =1)
predict(reg, newdata = as.data.frame(1))
reg
predict(reg, newdata = as.data.frame(1))
reg
predict(reg, newdata = data.frame(1))
test <- data.frame(1,2)
colnames(test) <- c($x$,$y$)
colnames(test) <- c("x","y")
test <- data.frame(1,2)
colnames(test) <- c("x","y")
predict(reg, newdata = test)
predict(reg, newdata = test, interval = "prediction")
7.960343 - 6.214406
1.745937 / qnorm(.975)
qnorm(.975)
1.745937 / qnorm(.975)
sd(reg$residuals)
sqrt(sum(reg^2))
mean(sqrt(sum(reg^2)))
mean(sqrt(sum(reg$residuals^2)))
qnorm(.99)
qnorm(0.01)
qnorm(0.01)
#trovare l'incremento riconoscibile con potenza 99
# .99 = 1-phi()
# phi() = .01
# z_a - d sqrt(n)/s = phi^{-1} (0.01)
#d = (z_a - phi^{-1} (0.01)) * sigma / sqrt(n)
d <- (1.64 - qnorm(0.01)) * sigma / sqrt(n)
#trovare l'incremento riconoscibile con potenza 99
# .99 = 1-phi()
# phi() = .01
# z_a - d sqrt(n)/s = phi^{-1} (0.01)
#d = (z_a - phi^{-1} (0.01)) * sigma / sqrt(n)
d <- (1.64 - qnorm(0.01)) * sigma / sqrt(n)
d
#trovare l'incremento riconoscibile con potenza 99
# .99 = 1-phi()
# phi() = .01
# z_a - d sqrt(n)/s = phi^{-1} (0.01)
#d = (z_a - phi^{-1} (0.01)) * sigma / sqrt(n)
d <- (1.64 - qnorm(0.01)) * sigma / sqrt(n)
#potenza
delta = 2
z_alpha = qnorm(.95)
sigma <- 4
n <- 36
z1 <- z_alpha - delta * sqrt(n) / sigma  #-1.355146
potenza = 1 - pnorm(z1) # 0.9123145
#trovare l'incremento riconoscibile con potenza 99
# .99 = 1-phi()
# phi() = .01
# z_a - d sqrt(n)/s = phi^{-1} (0.01)
#d = (z_a - phi^{-1} (0.01)) * sigma / sqrt(n)
d <- (1.64 - qnorm(0.01)) * sigma / sqrt(n)
#trovare l'incremento riconoscibile con potenza 99
# .99 = 1-phi()
# phi() = .01
# z_a - d sqrt(n)/s = phi^{-1} (0.01)
#d = (z_a - phi^{-1} (0.01)) * sigma / sqrt(n)
d <- (1.64 - qnorm(0.01)) * sigma / sqrt(n)
d
qnorm(0.01)
z1 <- z_alpha - 2 * sqrt(81) / 6
z1 <- qnorm(.95) - 2 * sqrt(81) / 6
z1
1 - pnorm(0)
1 - pnorm(1.35)
1 - pnorm(1.355146)
1 - pnorm(1.355146)
pnorm(1.355146)
z_alpha = qnorm(.95)
sigma <- 4
n <- 36
z1 <- z_alpha - delta * sqrt(n) / sigma  #-1.355146
#potenza
delta = 2
z_alpha = qnorm(.95)
sigma <- 4
n <- 36
z1 <- z_alpha - delta * sqrt(n) / sigma  #-1.355146
z1
potenza = 1 - pnorm(z1) # 0.9123145
potenza
qnorm(.95)
qnorm(0.01)
(qnorm(0.01) + 1.645) / -1.5
(1.645 + 2.32)/1.5
#trovare l'incremento riconoscibile con potenza 99
# .99 = 1-phi()
# phi() = .01
# z_a - d sqrt(n)/s = phi^{-1} (0.01)
# z_a - d sqrt(n)/s = -2.32
# d  = (-2.32  - 1.64) * s /sqrt(n)
d <- (qnorm(0.01) - qnorm(0.05)) * sigma / sqrt(n) #2.66
d
#trovare l'incremento riconoscibile con potenza 99
# .99 = 1-phi()
# phi() = .01
# z_a - d sqrt(n)/s = phi^{-1} (0.01)
# z_a - d sqrt(n)/s = -2.32
# d  = (-2.32  - 1.64) * s /sqrt(n)
d <- (-qnorm(0.01) - qnorm(0.05)) * sigma / sqrt(n) #2.66
d
pnorm(0.1)
1norm(0.1)
qnorm(0.1)
qnorm(0.01)
x <- rnorm(1000)
y <- x + rnorm(1000, sd=0.2)
plot(x,y)
x <- rnorm(1000)
y <- x + rnorm(1000, sd=0.5)
plot(x,y)
?rnorm
x <- rnorm(1000, mean=5)
y <- x + rnorm(1000, sd=0.5)
plot(x,y)
x <- rnorm(1000, mean=5)
y <- x + rnorm(1000, sd=0.5)
plot(x,y)
fit <- lm (y ~ x)
fit
x <- rnorm(1000, mean=5)
y <- 3+ x + rnorm(1000, sd=0.5)
plot(x,y)
fit <- lm (y ~ x)
fit
x_std <- (x - mean(x)) / sd(x)
y_std <- (y - mean(y)) / sd(y)
fit2 <- lm (y_std ~ x_std)
fit2
x_std <- (x - mean(x)) / sd(x)
x2_std <- (x - mean(x2)) / sd(2)
y_std <- (y - mean(y)) / sd(y)
fit2 <- lm (y_std ~ x_std + x2_std)
x_std <- (x - mean(x)) / sd(x)
x2_std <- (x - mean(x2)) / sd(2)
x2 <- rnorm(1000, mean=6)
y <- 3+ x + rnorm(1000, sd=0.5) + x2
x_std <- (x - mean(x)) / sd(x)
x2_std <- (x - mean(x2)) / sd(2)
y_std <- (y - mean(y)) / sd(y)
fit2 <- lm (y_std ~ x_std + x2_std)
x <- rnorm(1000, mean=5)
x2 <- rnorm(1000, mean=6)
y <- 3 + x + rnorm(1000, sd=0.5) + x2
plot(x,y)
plot(x2,y)
x_std <- (x - mean(x)) / sd(x)
x2_std <- (x - mean(x2)) / sd(x2)
y_std <- (y - mean(y)) / sd(y)
fit2 <- lm (y_std ~ x_std + x2_std)
fit2
library(tscount)
?campy
library(fpp2)
autoplot(campy)
fit <- ets(campy)
fit
library(thief)
a <- tsaggregates(campy)
?campy
fit <- auto.arima(campy)
fit
#p value proporzione, una coda
p_a <- 150/200
p_b <- 200/250
p_bar <- 350 / 450
p_bar
z <- (p_a - p_b) / sqrt (p_bar * (1 - p_bar) * (1/200 + 1/250))
z
