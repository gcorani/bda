lik   = norm.pdf(168, loc=current_mu, scale=current_sigma)
#lik   = lik * norm.pdf(178, loc=current_mu, scale=current_sigma)
#unnormalized density
post_density[row,col] = prior * lik
post_density = post_density/np.nansum(post_density)
post_density = post_density/np.sum(post_density)
plt.figure(figsize=(10, 3))
plt.matshow(post_density)
plt.title("Joint")
plt.show()
plt.subplot(1, 2, 1)
post_mu = np.nansum(post_density, axis=1)
plt.plot(mu,post_mu)
plt.title("Post mean")
plt.show()
post_sigma = np.nansum(post_density, axis=0)
plt.subplot(1, 2, 2)
plt.plot(sigma,post_sigma)
plt.title("Post sigma")
plt.show()
post_sigma = np.sum(post_density, axis=0)
plt.subplot(1, 2, 2)
plt.plot(sigma,post_sigma)
plt.title("Post sigma")
plt.show()
mu_len = 80
mu = np.linspace(145, 205, mu_len)
#the sigma has a broad range (see slides: 75% pctile is 40; max is 128 and we use more points)
#the value of 0 is not feasible.
#we would better have a non-uniform grid
sigma = np.linspace(0.01, 100, 120)
post_density = np.zeros( ( len(mu),len(sigma) ) )
#we could vectorize the code. But here we aim at clarity.
for row, current_mu in enumerate(mu):
for col, current_sigma in enumerate(sigma):
#prior: prior(current_mu) * density(current_sigma)
# we assume the priors p(mu) and p(sigma) to be independent
prior = norm.pdf(current_mu, loc=175, scale=5)
prior = prior * halfnorm.pdf(current_sigma, scale=35)
#assuming independence of the y_i, the lik terms multiply
lik   = norm.pdf(168, loc=current_mu, scale=current_sigma)
lik   = lik * norm.pdf(178, loc=current_mu, scale=current_sigma)
#unnormalized density
post_density[row,col] = prior * lik
post_density = post_density/np.sum(post_density)
#for very small values of sigma, the posterior mean
#equals the  mean of the data.
#otherwise, it basically equals the prior mean since there is
#only a single observation.
plt.figure(figsize=(10, 3))
plt.matshow(post_density)
plt.title("Joint")
plt.show()
plt.subplot(1, 2, 1)
post_mu = np.nansum(post_density, axis=1)
plt.plot(mu,post_mu)
plt.title("Post mean")
#posterior marginal of sigma
post_sigma = np.sum(post_density, axis=0)
plt.subplot(1, 2, 2)
plt.plot(sigma,post_sigma)
plt.title("Post sigma")
plt.show()
plt.figure(figsize=(10, 3))
plt.matshow(post_density)
plt.title("Joint")
plt.show()
plt.figure(figsize=(10, 3))
plt.matshow(post_density[30:50,0:40])
plt.title("Joint")
plt.show()
plt.title("Joint")
plt.matshow(post_density[30:50,0:40])
plt.title("Joint")
plt.show()
plt.subplot(1, 2, 1)
post_mu = np.nansum(post_density, axis=1)
plt.plot(mu,post_mu)
plt.title("Post mean")
#posterior marginal of sigma
post_sigma = np.sum(post_density, axis=0)
plt.subplot(1, 2, 2)
plt.plot(sigma,post_sigma)
plt.title("Post sigma")
plt.show()
library(fpp2)
elecdemand
?elecdemand
qnorm(.1)
library(fpp2)
fitses <- ses(chicken)
fitholt <- holt(chicken)
summary(fitses)
summary(holtfit)
summary(fitholt)
fit <- ets(usdeaths)
summary(fit)
autoplot(h02)
?h02
autoplot(h02)
coef(fit)
fit <- ets(usdeaths)
autoplot(fit)
fit <- ets(usdeaths)
fc  <- forecast (fit, h=12)
accuracy(fc)
ets(ibmclose)
ets(ausbeer)
ets(bicoal)
ets(dole)
autoplot(dole)
?dole
#simulates 200 random walks of length 20
rw<-matrix(nrow = 200, ncol=20, data = 0)
#cycle over simulations
for (sim in (1:200)){ #cycle over t
for (t in (2:20)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
} }
#simulates 200 random walks of length 20
rw<-matrix(nrow = 200, ncol=20, data = 0)
rw_diff<-matrix(nrow = 200, ncol=20, data = 0)
#simulates 200 random walks of length 20
rw<-matrix(nrow = 200, ncol=20, data = 0)
rw_diff<-matrix(nrow = 200, ncol=20, data = 0)
#cycle over simulations
for (sim in (1:200)){ #cycle over t
for (t in (2:20)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
autoplot(rw)
plot(rw)
rw <- mts(rw)
library(fpp2)
rw <- mts(rw)
rw <- ts(rw)
autoplot(rw)
autoplot(rw_diff)
rw <- ts(rw)
rw_diff <- ts(rw_diff)
autoplot(rw)
autoplot(rw_diff)
rw
hear(rw)
head(rw)
rw <- ts(t(rw))
autoplot(rw)
#simulates 200 random walks of length 20
rw<-matrix(nrow = 20, ncol=20, data = 0)
rw_diff<-matrix(nrow = 20, ncol=20, data = 0)
#cycle over simulations
for (sim in (1:20)){ #cycle over t
for (t in (2:20)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
rw <- ts(t(rw))
rw_diff <- ts(rw_diff)
autoplot(rw)
autoplot(rw_diff)
#simulates 20 random walks of length 30
rw<-matrix(nrow = 20, ncol=30, data = 0)
rw_diff<-matrix(nrow = 20, ncol=30, data = 0)
#cycle over simulations
for (sim in (1:20)){ #cycle over t
for (t in (2:20)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
#cycle over simulations
for (sim in (1:20)){ #cycle over t
for (t in (2:30)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
rw <- ts(t(rw))
rw_diff <- ts(rw_diff)
autoplot(rw)
autoplot(rw_diff)
autoplot(rw)
autoplot(rw_diff)
train   <- window(chicken, end=1980)
test    <- window(chicken, start=1981)
sesFit  <- ses  (train, h =length(test))
holtFit <- holt (train, h =length(test))
accuracy(sesFit)
accuracy(sesFit, test)
accuracy(holtFit, test)
summary(holtFit)
summary(sesFit)
?usdeaths
autoplot(usdeaths)
fit <- ets(usdeaths)
autoplot(fit)
?h02
autoplot(h01)
autoplot(h02)
fit2 <- ets(h01)
fit2 <- ets(h02)
summary(fit2)
autoplot(fit2)
fit <- ets(usdeaths)
autoplot(visitors)
?visitors
autoplot(visitors)
autoplot( log(visitors))
autoplot( diff(log(visitors), lag=12))
ggAcf( diff(log(visitors), lag=12))
autoplot( diff(diff(log(visitors), lag=12)))
ggAcf( diff(diff(log(visitors), lag=12)))
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
#simulates 20 random walks of length 30
rw<-matrix(nrow = 20, ncol=30, data = 0)
ar<-matrix(nrow = 20, ncol=30, data = 0)
rw_diff<-matrix(nrow = 20, ncol=30, data = 0)
phi <- 0.8
#cycle over simulations
for (sim in (1:20)){ #cycle over t
for (t in (2:30)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
ar[sim,t] <- phi * rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
rw <- ts(t(rw))
rw_diff <- ts(rw_diff)
autoplot(rw)
autoplot(rw_diff)
#to be interpreted correctly by the  ts function, the simulated data
#should be transposed (colums: the different simulations; rows: time)
rw <- ts(t(rw))
rw_diff <- ts(t(rw_diff))
ar <- ts(t(ar))
autoplot(ar)
ar <- ts(t(ar))
autoplot(rw)
autoplot(rw_diff)
autoplot(ar)
#cycle over simulations
for (sim in (1:20)){ #cycle over t
for (t in (2:30)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
ar[sim,t] <- phi * rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
autoplot(ts(ar))
autoplot(ts(t(ar))
autoplot(ts(t(ar)))
autoplot(ts(t(ar)))
#simulates 20 random walks of length T
T <- 40
sims <- 20
rw<-matrix(nrow = sims, ncol=T, data = 0)
ar<-matrix(nrow = sims, ncol=T, data = 0)
rw_diff<-matrix(nrow = sims, ncol=T, data = 0)
phi <- 0.8
#cycle over simulations
for (sim in (1:sims)){
#cycle over t
for (t in (2:T)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
ar[sim,t] <- phi * rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
autoplot(rw)
autoplot(rw_diff)
autoplot(rw)
autoplot(ts(rw))
autoplot(ts(t(rw)))
autoplot(ts(t(rw_diff)))
autoplot(ts(t(rw)))
autoplot(ts(t(ar)))
#simulates 20 random walks of length T
T <- 100
sims <- 20
rw<-matrix(nrow = sims, ncol=T, data = 0)
ar<-matrix(nrow = sims, ncol=T, data = 0)
rw_diff<-matrix(nrow = sims, ncol=T, data = 0)
phi <- 0.8
#cycle over simulations
for (sim in (1:sims)){
#cycle over t
for (t in (2:T)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
ar[sim,t] <- phi * rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
autoplot(ts(t(rw)))
autoplot(ts(t(rw_diff)))
autoplot(ts(t(ar)))
autoplot(ts(t(rw)))
autoplot(ts(t(rw_diff)))
autoplot(ts(t(ar)))
#simulates 20 random walks of length T
T <- 200
sims <- 20
rw<-matrix(nrow = sims, ncol=T, data = 0)
ar<-matrix(nrow = sims, ncol=T, data = 0)
rw_diff<-matrix(nrow = sims, ncol=T, data = 0)
phi <- 0.8
#cycle over simulations
for (sim in (1:sims)){
#cycle over t
for (t in (2:T)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
ar[sim,t] <- phi * rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
autoplot(ts(t(rw)))
autoplot(ts(t(rw_diff)))
autoplot(ts(t(rw)))
autoplot(ts(t(rw_diff)))
#statiorary, apart from the very first instants
autoplot(ts(t(ar)))
#cycle over simulations
for (sim in (1:sims)){
#cycle over t
for (t in (2:T)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <-rw[sim,t-1] + rnorm(1)
ar[sim,t] <- phi * ar[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
autoplot(ts(t(rw)))
autoplot(ts(t(rw_diff)))
#statiorary, apart from the very first instants
autoplot(ts(t(ar)))
autoplot(ts(t(rw)))
autoplot(ts(t(rw_diff)))
#statiorary, apart from the very first instants
autoplot(ts(t(ar)))
library(fpp2)
Arima(lynx, order=c(1,1,0),
include.constant=FALSE)
a <- Arima(lynx, order=c(1,1,0),
include.constant=FALSE)
autoplot(forecast(a, h=50))
autoplot(forecast(a, h=50), PI = FALSE)
library(fpp2)
autoplot(internet)
fitAuto <- auto.arima(internet)
summary(fitAuto)
autoplot(fit)
autoplot(fitAuto)
usdeaths
dowjones
autoplot(usdeaths)
nsdiffs(usdeaths)
autoplot( diff(usdeaths, lag=12))
ndiffs ( diff(usdeaths, lag=12))
autoplot ( diff(diff(usdeaths, lag=12)))
autoplot(ibmclose)
nsdiffs(ibmclose)
ndiffs(ibmclose)
autoplot(diff(ibmclose))
autoplot(inter)
autoplot(internet)
?internet
autoplot(internet)
fit <- Arima(internet, order=c(3,1,0), include.constant= FALSE)
summary(fit)
fc <- forecast(fit)
fc
autoplot(fc)
checkresiduals(fit)
fitAuto <- auto.arima(internet)
summary(fitAuto)
checkresiduals(fitAuto)
autoplot(usdeaths)
fit <- auto.arima(usdeaths)
summary(fit)
p <- c(.6, .4)
mixture <- sample(c(0,1),size=10000,prob=p)
#array of 0(40%) and 1(60%)
mixture <- rbinom(1, 10000, prob = .6)
mixture
#array of 0(40%) and 1(60%)
mixture <- runif(10000)
#array of 0(40%) and 1(60%)
mixture <- runif(10000)
mixture[mixture>.4] <- 1
mixture[mixture<1] <- 0
mixture
summary(mixture)
peaks <- vector(length = length(mixture))
peaks[mixture==1] <- 20
peaks[mixture==0] <- 8
#mae of the mode
mae_mode <- mean(abs(peaks-20))
mae_mode
#mae of the median
expected_hour <- 20*.6 + 8*.4
#mae of the median
expected_hour <- 20*.6 + 8*.4
expected_hour
#mae of the mode
mae_mode <- mean(abs(peaks-20))
#mae of the median
expected_hour <- 20*.6 + 8*.4
mae_mean <- mean(abs(peaks-expected_hour))
mae_mean
mae_mode
set.seed(1)
xx <- rlnorm(1e7)
yy <- sqrt(exp(1))
yy
mean(abs(xx-yy)/xx)
mean((xx-yy)^2)
yy <- 1/exp(1)
yy
mean(abs(xx-yy)/xx)
mean((xx-yy)^2)
summary(xx)
a <- rnorm(10000)
b <- rnorm(10000, mean = 2)
c <- rnorm(10000, mean = 3)
df <- data.frame(cbind(a,b,c))
df
df$max <- apply(df, 1, max, na.rm=TRUE)
df
View(df)
View(df)
df$max <- apply(df, 1, which.max, na.rm=TRUE)
df$max <- apply(df, 1, which.max)
p1 <- mean(df$max==1)
p2 <- mean(df$max==2)
p3 <- mean(df$max==3)
p1
p2
p3
3/(1+2+3)
set.seed(1)
x<-cbind(a,b)
a<-rnorm(10000, mean=8)
b<-rnorm(10000, mean=20)
x<-cbind(a,b)
hist(x)
set.seed(1)
a<-rnorm(10000, mean=8, sd=2)
b<-rnorm(10000, mean=20, sd=2)
x<-cbind(a,b)
hist(x)
md <- median(x)
set.seed(1)
a<-rnorm(10000, mean=8, sd=2)
b<-rnorm(15000, mean=20, sd=2)
x<-cbind(a,b)
hist(x)
set.seed(1)
a<-rnorm(10000, mean=8, sd=2)
b<-rnorm(20000, mean=20, sd=2)
x<-cbind(a,b)
hist(x)
length(x)
a<-rnorm(10000, mean=8, sd=2)
b<-rnorm(20000, mean=20, sd=2)
x<-cbind(a,b)
rbind(a,b)
cbind(a,b)
x<-rbind(a,b)
hist(x)
summary(x)
a<-rnorm(10000, mean=8, sd=2)
b<-rnorm(20000, mean=20, sd=2)
x<-c(a,b)
hist(x)
md <- median(x)
md
#
mae_median <- mean(abs(x - median(x)))
mae_mean <- mean(abs(x - mean(x)))
mae_mode <- mean(abs(x - 20))
mape_median <- mean(abs(x - median(x)/x))
mape_mean <- mean(abs(x - mean(x)/x))
mape_mode <- mean(abs(x - 20)/x)
#
mae_median <- mean(abs(x - median(x)))
mae_mean <- mean(abs(x - mean(x)))
mae_mode <- mean(abs(x - 20))
mape_mode <- mean(abs(x - 20)/x))
mape_median <- mean(abs(x - median(x))/x)
mape_median <- mean( abs(x - median(x)) / x)
mape_mean   <- mean( abs(x - mean(x))   / x)
mape_mode   <- mean( abs(x - 20)        /x)
mape_median <- mean( abs(x - median(x)) / x)
mape_mean   <- mean( abs(x - mean(x))   / x)
#
mae_median <- mean(abs(x - median(x)))
mae_mean <- mean(abs(x - mean(x)))
mae_mode <- mean(abs(x - 20))
mape_median <- mean( abs(x - median(x)) / x)
mape_mean   <- mean( abs(x - mean(x))   / x)
mape_mode   <- mean( abs(x - 20)        /x)
