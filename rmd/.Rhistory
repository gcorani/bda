import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.stats import halfnorm
import matplotlib.pyplot as plt
mu_len = 80
mu = np.linspace(145, 205, mu_len)
sigma = np.linspace(0, 100, 120)
post_density = np.zeros( ( len(mu),len(sigma) ) )
for row, current_mu in enumerate(mu):
for col, current_sigma in enumerate(sigma):
#prior: prior(current_mu) * density(current_sigma)
# we assume the priors p(mu) and p(sigma) to be independent
prior = norm.pdf(current_mu, loc=175, scale=5)
prior = prior * halfnorm.pdf(current_sigma, scale=35)
prior
current_mu
current_sigma
prior = norm.pdf(current_mu, loc=175, scale=5)
prior = prior * halfnorm.pdf(current_sigma, scale=35)
#assuming independence of the y_i, the lik terms multiply
lik   = norm.pdf(168, loc=current_mu, scale=current_sigma)
lik
post_density[row,col] = prior * lik
for row, current_mu in enumerate(mu):
for col, current_sigma in enumerate(sigma):
#prior: prior(current_mu) * density(current_sigma)
# we assume the priors p(mu) and p(sigma) to be independent
prior = norm.pdf(current_mu, loc=175, scale=5)
prior = prior * halfnorm.pdf(current_sigma, scale=35)
#assuming independence of the y_i, the lik terms multiply
lik   = norm.pdf(168, loc=current_mu, scale=current_sigma)
#lik   = lik * norm.pdf(178, loc=current_mu, scale=current_sigma)
#unnormalized density
post_density[row,col] = prior * lik
post_density
sigma[0]
sigma = np.linspace(0.01, 100, 120)
post_density = np.zeros( ( len(mu),len(sigma) ) )
for row, current_mu in enumerate(mu):
for col, current_sigma in enumerate(sigma):
#prior: prior(current_mu) * density(current_sigma)
# we assume the priors p(mu) and p(sigma) to be independent
prior = norm.pdf(current_mu, loc=175, scale=5)
prior = prior * halfnorm.pdf(current_sigma, scale=35)
#assuming independence of the y_i, the lik terms multiply
lik   = norm.pdf(168, loc=current_mu, scale=current_sigma)
#lik   = lik * norm.pdf(178, loc=current_mu, scale=current_sigma)
#unnormalized density
post_density[row,col] = prior * lik
post_density = post_density/np.nansum(post_density)
post_density = post_density/np.sum(post_density)
plt.figure(figsize=(10, 3))
plt.matshow(post_density)
plt.title("Joint")
plt.show()
plt.subplot(1, 2, 1)
post_mu = np.nansum(post_density, axis=1)
plt.plot(mu,post_mu)
plt.title("Post mean")
plt.show()
post_sigma = np.nansum(post_density, axis=0)
plt.subplot(1, 2, 2)
plt.plot(sigma,post_sigma)
plt.title("Post sigma")
plt.show()
post_sigma = np.sum(post_density, axis=0)
plt.subplot(1, 2, 2)
plt.plot(sigma,post_sigma)
plt.title("Post sigma")
plt.show()
mu_len = 80
mu = np.linspace(145, 205, mu_len)
#the sigma has a broad range (see slides: 75% pctile is 40; max is 128 and we use more points)
#the value of 0 is not feasible.
#we would better have a non-uniform grid
sigma = np.linspace(0.01, 100, 120)
post_density = np.zeros( ( len(mu),len(sigma) ) )
#we could vectorize the code. But here we aim at clarity.
for row, current_mu in enumerate(mu):
for col, current_sigma in enumerate(sigma):
#prior: prior(current_mu) * density(current_sigma)
# we assume the priors p(mu) and p(sigma) to be independent
prior = norm.pdf(current_mu, loc=175, scale=5)
prior = prior * halfnorm.pdf(current_sigma, scale=35)
#assuming independence of the y_i, the lik terms multiply
lik   = norm.pdf(168, loc=current_mu, scale=current_sigma)
lik   = lik * norm.pdf(178, loc=current_mu, scale=current_sigma)
#unnormalized density
post_density[row,col] = prior * lik
post_density = post_density/np.sum(post_density)
#for very small values of sigma, the posterior mean
#equals the  mean of the data.
#otherwise, it basically equals the prior mean since there is
#only a single observation.
plt.figure(figsize=(10, 3))
plt.matshow(post_density)
plt.title("Joint")
plt.show()
plt.subplot(1, 2, 1)
post_mu = np.nansum(post_density, axis=1)
plt.plot(mu,post_mu)
plt.title("Post mean")
#posterior marginal of sigma
post_sigma = np.sum(post_density, axis=0)
plt.subplot(1, 2, 2)
plt.plot(sigma,post_sigma)
plt.title("Post sigma")
plt.show()
plt.figure(figsize=(10, 3))
plt.matshow(post_density)
plt.title("Joint")
plt.show()
plt.figure(figsize=(10, 3))
plt.matshow(post_density[30:50,0:40])
plt.title("Joint")
plt.show()
plt.title("Joint")
plt.matshow(post_density[30:50,0:40])
plt.title("Joint")
plt.show()
plt.subplot(1, 2, 1)
post_mu = np.nansum(post_density, axis=1)
plt.plot(mu,post_mu)
plt.title("Post mean")
#posterior marginal of sigma
post_sigma = np.sum(post_density, axis=0)
plt.subplot(1, 2, 2)
plt.plot(sigma,post_sigma)
plt.title("Post sigma")
plt.show()
library(fpp2)
elecdemand
?elecdemand
qnorm(.1)
library(fpp2)
fitses <- ses(chicken)
fitholt <- holt(chicken)
summary(fitses)
summary(holtfit)
summary(fitholt)
fit <- ets(usdeaths)
summary(fit)
autoplot(h02)
?h02
autoplot(h02)
coef(fit)
fit <- ets(usdeaths)
autoplot(fit)
fit <- ets(usdeaths)
fc  <- forecast (fit, h=12)
accuracy(fc)
ets(ibmclose)
ets(ausbeer)
ets(bicoal)
ets(dole)
autoplot(dole)
?dole
#simulates 200 random walks of length 20
rw<-matrix(nrow = 200, ncol=20, data = 0)
#cycle over simulations
for (sim in (1:200)){ #cycle over t
for (t in (2:20)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
} }
#simulates 200 random walks of length 20
rw<-matrix(nrow = 200, ncol=20, data = 0)
rw_diff<-matrix(nrow = 200, ncol=20, data = 0)
#simulates 200 random walks of length 20
rw<-matrix(nrow = 200, ncol=20, data = 0)
rw_diff<-matrix(nrow = 200, ncol=20, data = 0)
#cycle over simulations
for (sim in (1:200)){ #cycle over t
for (t in (2:20)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
autoplot(rw)
plot(rw)
rw <- mts(rw)
library(fpp2)
rw <- mts(rw)
rw <- ts(rw)
autoplot(rw)
autoplot(rw_diff)
rw <- ts(rw)
rw_diff <- ts(rw_diff)
autoplot(rw)
autoplot(rw_diff)
rw
hear(rw)
head(rw)
rw <- ts(t(rw))
autoplot(rw)
#simulates 200 random walks of length 20
rw<-matrix(nrow = 20, ncol=20, data = 0)
rw_diff<-matrix(nrow = 20, ncol=20, data = 0)
#cycle over simulations
for (sim in (1:20)){ #cycle over t
for (t in (2:20)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
rw <- ts(t(rw))
rw_diff <- ts(rw_diff)
autoplot(rw)
autoplot(rw_diff)
#simulates 20 random walks of length 30
rw<-matrix(nrow = 20, ncol=30, data = 0)
rw_diff<-matrix(nrow = 20, ncol=30, data = 0)
#cycle over simulations
for (sim in (1:20)){ #cycle over t
for (t in (2:20)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
#cycle over simulations
for (sim in (1:20)){ #cycle over t
for (t in (2:30)) {
#rnorm(1) is a single draw from N(0,1) #let us assume c=0
rw[sim,t] <- 0 + rw[sim,t-1] + rnorm(1)
rw_diff[sim,t] <- rw[sim,t] - rw[sim,t-1]
} }
library(fpp2)
rw <- ts(t(rw))
rw_diff <- ts(rw_diff)
autoplot(rw)
autoplot(rw_diff)
autoplot(rw)
autoplot(rw_diff)
train   <- window(chicken, end=1980)
test    <- window(chicken, start=1981)
sesFit  <- ses  (train, h =length(test))
holtFit <- holt (train, h =length(test))
accuracy(sesFit)
accuracy(sesFit, test)
accuracy(holtFit, test)
summary(holtFit)
summary(sesFit)
?usdeaths
autoplot(usdeaths)
fit <- ets(usdeaths)
autoplot(fit)
?h02
autoplot(h01)
autoplot(h02)
fit2 <- ets(h01)
fit2 <- ets(h02)
summary(fit2)
autoplot(fit2)
fit <- ets(usdeaths)
autoplot(visitors)
?visitors
autoplot(visitors)
autoplot( log(visitors))
autoplot( diff(log(visitors), lag=12))
ggAcf( diff(log(visitors), lag=12))
autoplot( diff(diff(log(visitors), lag=12)))
ggAcf( diff(diff(log(visitors), lag=12)))
