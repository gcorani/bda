#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if (density=='lognormal')
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 1
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if (density=='lognormal')
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("PE media")
print(mpe_mean_a)
print("PE minimizer")
print(mpe_pe_minimizer)
source("~/switchdrive/devel/bigDealCompetition/mape.R", echo=TRUE)
source("~/switchdrive/devel/bigDealCompetition/mape.R", echo=TRUE)
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 1
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("PE media")
print(mpe_mean_a)
print("PE minimizer")
print(mpe_pe_minimizer)
mpe_mean_a
source("~/switchdrive/devel/bigDealCompetition/mape.R", echo=TRUE)
print("PE media")
print(mpe_mean_a)
print("PE minimizer")
print(mpe_pe_minimizer)
mpe_mean_a
mpe_mean_a
pe_minimizer
print(c(mpe_mean_a, mpe_pe_minimizer))
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 1
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 100
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 10
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 20
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 30
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 10
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 20
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
(177 - 173)/175
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 100
s <- 30
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
(346 - 323) / 330
set.seed(1)
#--------comparing mean and minimizer of ape
#parametri lognormale
m <- 193
s <- 11
density <- "normal"
#density <- "lognormal"
#a<-rnorm(10000, mean=m, sd=s)
#caso lognormale, vedi https://stats.stackexchange.com/questions/213897/best-way-to-optimize-mape
if (density=='normal')
a<-rnorm(10000, mean=m, sd=s)
if ( (density=='lognormal') )
a<-rlnorm(10000, mean=m, sd=s)
#discretized domain of y divided in 10000 steps
step <- (max(a) - min(a)) / 10000
y <- seq ( from=(min(a)), to=(max(a)), by=step)
#lognormal density
if  (density=='normal')
density <- dnorm(y, mean=m, sd=s)
if  (density=='lognormal')
density <- dlnorm(y, mean=m, sd=s)
df <- cbind(y, density, (density/y), 0)
colnames(df) <- c("y", "density","density/y","derived_cumulative")
##Build the derived density
df[1,"derived_cumulative"] <- df[1,"density/y"] * step
for (i in 2:nrow(df)){
df[i,"derived_cumulative"] <- df[i-1,"derived_cumulative"] +  df[i,"density/y"] * step
}
#non sembra funzionare...
df[,"derived_cumulative"] <- df[,"derived_cumulative"]/df[nrow(df),"derived_cumulative"]
#lookup to find the median
pe_minimizer<- approx(df[,"derived_cumulative"], df[,"y"], xout = 0.5)$y
#0.366
mse_pe_minimizer <- mean( ((a - pe_minimizer)^2) ) #6.05
mpe_pe_minimizer <- mean( abs(abs(a - pe_minimizer)/a) ) #0.69
#using mean as point forecast
mean_a <- mean(a)
mse_mean_a <- mean( ((a - mean_a)^2) ) #4.41
mpe_mean_a <- mean( abs(abs(a - mean_a)/a) ) #2.03
print("media, minimizer")
print(c(mpe_mean_a, mpe_pe_minimizer))
(0.04628467 - 0.04619630) / 0.04619630
library(bayesrule)
library(bayesrules)
data("bikes")
force(bikes)
View(bikes)
pwd()
setwd("~/switchdrive/teaching/BayesianProg/bda/rmd")
write.csv(bikes, file="bikes.csv",row.names = FALSE, col.names = TRUE )
